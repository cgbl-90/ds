{"version":3,"file":"static/js/async/client-reporting-sentiment-analysis-components-SentimentAnalysisSummary-stories.f46dfcee.iframe.bundle.js","sources":["webpack://@mention-me/frontend/../node_modules/msw/lib/core/handlers/GraphQLHandler.mjs"],"sourcesContent":["import {\n  RequestHandler\n} from './RequestHandler.mjs';\nimport { getTimestamp } from '../utils/logging/getTimestamp.mjs';\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor.mjs';\nimport { serializeRequest } from '../utils/logging/serializeRequest.mjs';\nimport { serializeResponse } from '../utils/logging/serializeResponse.mjs';\nimport { matchRequestUrl } from '../utils/matching/matchRequestUrl.mjs';\nimport {\n  parseGraphQLRequest,\n  parseDocumentNode\n} from '../utils/internal/parseGraphQLRequest.mjs';\nimport { toPublicUrl } from '../utils/request/toPublicUrl.mjs';\nimport { devUtils } from '../utils/internal/devUtils.mjs';\nimport { getAllRequestCookies } from '../utils/request/getRequestCookies.mjs';\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nclass GraphQLHandler extends RequestHandler {\n  endpoint;\n  static parsedRequestCache = /* @__PURE__ */ new WeakMap();\n  constructor(operationType, operationName, endpoint, resolver, options) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      resolver,\n      options\n    });\n    this.endpoint = endpoint;\n  }\n  /**\n   * Parses the request body, once per request, cached across all\n   * GraphQL handlers. This is done to avoid multiple parsing of the\n   * request body, which each requires a clone of the request.\n   */\n  async parseGraphQLRequestOrGetFromCache(request) {\n    if (!GraphQLHandler.parsedRequestCache.has(request)) {\n      GraphQLHandler.parsedRequestCache.set(\n        request,\n        await parseGraphQLRequest(request).catch((error) => {\n          console.error(error);\n          return void 0;\n        })\n      );\n    }\n    return GraphQLHandler.parsedRequestCache.get(request);\n  }\n  async parse(args) {\n    const match = matchRequestUrl(new URL(args.request.url), this.endpoint);\n    const cookies = getAllRequestCookies(args.request);\n    if (!match.matches) {\n      return { match, cookies };\n    }\n    const parsedResult = await this.parseGraphQLRequestOrGetFromCache(\n      args.request\n    );\n    if (typeof parsedResult === \"undefined\") {\n      return { match, cookies };\n    }\n    return {\n      match,\n      cookies,\n      query: parsedResult.query,\n      operationType: parsedResult.operationType,\n      operationName: parsedResult.operationName,\n      variables: parsedResult.variables\n    };\n  }\n  predicate(args) {\n    if (args.parsedResult.operationType === void 0) {\n      return false;\n    }\n    if (!args.parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = toPublicUrl(args.request.url);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${args.request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/#graphqloperationresolver`);\n      return false;\n    }\n    const hasMatchingOperationType = this.info.operationType === \"all\" || args.parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(args.parsedResult.operationName || \"\") : args.parsedResult.operationName === this.info.operationName;\n    return args.parsedResult.match.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  extendResolverArgs(args) {\n    return {\n      query: args.parsedResult.query || \"\",\n      operationName: args.parsedResult.operationName || \"\",\n      variables: args.parsedResult.variables || {},\n      cookies: args.parsedResult.cookies\n    };\n  }\n  async log(args) {\n    const loggedRequest = await serializeRequest(args.request);\n    const loggedResponse = await serializeResponse(args.response);\n    const statusColor = getStatusCodeColor(loggedResponse.status);\n    const requestInfo = args.parsedResult.operationName ? `${args.parsedResult.operationType} ${args.parsedResult.operationName}` : `anonymous ${args.parsedResult.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage(\n        `${getTimestamp()} ${requestInfo} (%c${loggedResponse.status} ${loggedResponse.statusText}%c)`\n      ),\n      `color:${statusColor}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n}\nexport {\n  GraphQLHandler,\n  isDocumentNode\n};\n//# sourceMappingURL=GraphQLHandler.mjs.map"],"names":[],"mappings":";;;AAkGA"}