{"version":3,"file":"static/js/async/6257.07f714b7.iframe.bundle.js","sources":["webpack://@mention-me/frontend/../node_modules/mermaid/dist/flowchart-elk-definition-930acc39.js"],"sourcesContent":["import { d as db, p as parser } from \"./flowDb-0da60e67.js\";\nimport { select, curveLinear, line } from \"d3\";\nimport { a as insertMarkers, e as insertNode, l as labelHelper, f as insertEdgeLabel, k as getLineFunctionsWithOffset, m as addEdgeMarkers } from \"./edges-5962ec63.js\";\nimport { l as log, F as getConfig, o as setupGraphViewbox, k as getStylesFromArray, n as interpolateToCurve, e as common } from \"./mermaid-2490e8f2.js\";\nimport ELK from \"elkjs/lib/elk.bundled.js\";\nimport \"./createText-4a4f35c9.js\";\nimport \"mdast-util-from-markdown\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nconst findCommonAncestor = (id1, id2, treeData) => {\n  const { parentById } = treeData;\n  const visited = /* @__PURE__ */ new Set();\n  let currentId = id1;\n  while (currentId) {\n    visited.add(currentId);\n    if (currentId === id2) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  currentId = id2;\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  return \"root\";\n};\nconst elk = new ELK();\nlet portPos = {};\nconst conf = {};\nlet nodeDb = {};\nconst addVertices = async function(vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert(\"g\").attr(\"class\", \"nodes\");\n  const keys = Object.keys(vert);\n  await Promise.all(\n    keys.map(async function(id) {\n      const vertex = vert[id];\n      let classStr = \"default\";\n      if (vertex.classes.length > 0) {\n        classStr = vertex.classes.join(\" \");\n      }\n      classStr = classStr + \" flowchart-label\";\n      const styles2 = getStylesFromArray(vertex.styles);\n      let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n      const labelData = { width: 0, height: 0 };\n      const ports = [\n        {\n          id: vertex.id + \"-west\",\n          layoutOptions: {\n            \"port.side\": \"WEST\"\n          }\n        },\n        {\n          id: vertex.id + \"-east\",\n          layoutOptions: {\n            \"port.side\": \"EAST\"\n          }\n        },\n        {\n          id: vertex.id + \"-south\",\n          layoutOptions: {\n            \"port.side\": \"SOUTH\"\n          }\n        },\n        {\n          id: vertex.id + \"-north\",\n          layoutOptions: {\n            \"port.side\": \"NORTH\"\n          }\n        }\n      ];\n      let radius = 0;\n      let _shape = \"\";\n      let layoutOptions = {};\n      switch (vertex.type) {\n        case \"round\":\n          radius = 5;\n          _shape = \"rect\";\n          break;\n        case \"square\":\n          _shape = \"rect\";\n          break;\n        case \"diamond\":\n          _shape = \"question\";\n          layoutOptions = {\n            portConstraints: \"FIXED_SIDE\"\n          };\n          break;\n        case \"hexagon\":\n          _shape = \"hexagon\";\n          break;\n        case \"odd\":\n          _shape = \"rect_left_inv_arrow\";\n          break;\n        case \"lean_right\":\n          _shape = \"lean_right\";\n          break;\n        case \"lean_left\":\n          _shape = \"lean_left\";\n          break;\n        case \"trapezoid\":\n          _shape = \"trapezoid\";\n          break;\n        case \"inv_trapezoid\":\n          _shape = \"inv_trapezoid\";\n          break;\n        case \"odd_right\":\n          _shape = \"rect_left_inv_arrow\";\n          break;\n        case \"circle\":\n          _shape = \"circle\";\n          break;\n        case \"ellipse\":\n          _shape = \"ellipse\";\n          break;\n        case \"stadium\":\n          _shape = \"stadium\";\n          break;\n        case \"subroutine\":\n          _shape = \"subroutine\";\n          break;\n        case \"cylinder\":\n          _shape = \"cylinder\";\n          break;\n        case \"group\":\n          _shape = \"rect\";\n          break;\n        case \"doublecircle\":\n          _shape = \"doublecircle\";\n          break;\n        default:\n          _shape = \"rect\";\n      }\n      const node = {\n        labelStyle: styles2.labelStyle,\n        shape: _shape,\n        labelText: vertexText,\n        labelType: vertex.labelType,\n        rx: radius,\n        ry: radius,\n        class: classStr,\n        style: styles2.style,\n        id: vertex.id,\n        link: vertex.link,\n        linkTarget: vertex.linkTarget,\n        tooltip: diagObj.db.getTooltip(vertex.id) || \"\",\n        domId: diagObj.db.lookUpDomId(vertex.id),\n        haveCallback: vertex.haveCallback,\n        width: vertex.type === \"group\" ? 500 : void 0,\n        dir: vertex.dir,\n        type: vertex.type,\n        props: vertex.props,\n        padding: getConfig().flowchart.padding\n      };\n      let boundingBox;\n      let nodeEl;\n      if (node.type !== \"group\") {\n        nodeEl = await insertNode(nodes, node, vertex.dir);\n        boundingBox = nodeEl.node().getBBox();\n      } else {\n        doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n        const { shapeSvg, bbox } = await labelHelper(nodes, node, void 0, true);\n        labelData.width = bbox.width;\n        labelData.wrappingWidth = getConfig().flowchart.wrappingWidth;\n        labelData.height = bbox.height;\n        labelData.labelNode = shapeSvg.node();\n        node.labelData = labelData;\n      }\n      const data = {\n        id: vertex.id,\n        ports: vertex.type === \"diamond\" ? ports : [],\n        // labelStyle: styles.labelStyle,\n        // shape: _shape,\n        layoutOptions,\n        labelText: vertexText,\n        labelData,\n        // labels: [{ text: vertexText }],\n        // rx: radius,\n        // ry: radius,\n        // class: classStr,\n        // style: styles.style,\n        // link: vertex.link,\n        // linkTarget: vertex.linkTarget,\n        // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n        domId: diagObj.db.lookUpDomId(vertex.id),\n        // haveCallback: vertex.haveCallback,\n        width: boundingBox == null ? void 0 : boundingBox.width,\n        height: boundingBox == null ? void 0 : boundingBox.height,\n        // dir: vertex.dir,\n        type: vertex.type,\n        // props: vertex.props,\n        // padding: getConfig().flowchart.padding,\n        // boundingBox,\n        el: nodeEl,\n        parent: parentLookupDb.parentById[vertex.id]\n      };\n      nodeDb[node.id] = data;\n    })\n  );\n  return graph;\n};\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos2 = {\n    TB: {\n      in: {\n        north: \"north\"\n      },\n      out: {\n        south: \"west\",\n        west: \"east\",\n        east: \"south\"\n      }\n    },\n    LR: {\n      in: {\n        west: \"west\"\n      },\n      out: {\n        east: \"south\",\n        south: \"north\",\n        north: \"east\"\n      }\n    },\n    RL: {\n      in: {\n        east: \"east\"\n      },\n      out: {\n        west: \"north\",\n        north: \"south\",\n        south: \"west\"\n      }\n    },\n    BT: {\n      in: {\n        south: \"south\"\n      },\n      out: {\n        north: \"east\",\n        east: \"west\",\n        west: \"north\"\n      }\n    }\n  };\n  portPos2.TD = portPos2.TB;\n  return portPos2[graphDirection][edgeDirection][position];\n};\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info(\"getNextPort\", { node, edgeDirection, graphDirection });\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case \"TB\":\n      case \"TD\":\n        portPos[node] = {\n          inPosition: \"north\",\n          outPosition: \"south\"\n        };\n        break;\n      case \"BT\":\n        portPos[node] = {\n          inPosition: \"south\",\n          outPosition: \"north\"\n        };\n        break;\n      case \"RL\":\n        portPos[node] = {\n          inPosition: \"east\",\n          outPosition: \"west\"\n        };\n        break;\n      case \"LR\":\n        portPos[node] = {\n          inPosition: \"west\",\n          outPosition: \"east\"\n        };\n        break;\n    }\n  }\n  const result = edgeDirection === \"in\" ? portPos[node].inPosition : portPos[node].outPosition;\n  if (edgeDirection === \"in\") {\n    portPos[node].inPosition = getNextPosition(\n      portPos[node].inPosition,\n      edgeDirection,\n      graphDirection\n    );\n  } else {\n    portPos[node].outPosition = getNextPosition(\n      portPos[node].outPosition,\n      edgeDirection,\n      graphDirection\n    );\n  }\n  return result;\n};\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n  const sourceId = source;\n  const targetId = target;\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n  if (!startNode || !endNode) {\n    return { source, target };\n  }\n  if (startNode.type === \"diamond\") {\n    source = `${source}-${getNextPort(source, \"out\", dir)}`;\n  }\n  if (endNode.type === \"diamond\") {\n    target = `${target}-${getNextPort(target, \"in\", dir)}`;\n  }\n  return { source, target, sourceId, targetId };\n};\nconst addEdges = function(edges, diagObj, graph, svg) {\n  log.info(\"abc78 edges = \", edges);\n  const labelsEl = svg.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n  if (edges.defaultStyle !== void 0) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n  edges.forEach(function(edge) {\n    const linkIdBase = \"L-\" + edge.start + \"-\" + edge.end;\n    if (linkIdCnt[linkIdBase] === void 0) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    }\n    let linkId = linkIdBase + \"-\" + linkIdCnt[linkIdBase];\n    log.info(\"abc78 new link id to be used is\", linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    const linkNameStart = \"LS-\" + edge.start;\n    const linkNameEnd = \"LE-\" + edge.end;\n    const edgeData = { style: \"\", labelStyle: \"\" };\n    edgeData.minlen = edge.length || 1;\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n    edgeData.arrowTypeStart = \"arrow_open\";\n    edgeData.arrowTypeEnd = \"arrow_open\";\n    switch (edge.type) {\n      case \"double_arrow_cross\":\n        edgeData.arrowTypeStart = \"arrow_cross\";\n      case \"arrow_cross\":\n        edgeData.arrowTypeEnd = \"arrow_cross\";\n        break;\n      case \"double_arrow_point\":\n        edgeData.arrowTypeStart = \"arrow_point\";\n      case \"arrow_point\":\n        edgeData.arrowTypeEnd = \"arrow_point\";\n        break;\n      case \"double_arrow_circle\":\n        edgeData.arrowTypeStart = \"arrow_circle\";\n      case \"arrow_circle\":\n        edgeData.arrowTypeEnd = \"arrow_circle\";\n        break;\n    }\n    let style = \"\";\n    let labelStyle = \"\";\n    switch (edge.stroke) {\n      case \"normal\":\n        style = \"fill:none;\";\n        if (defaultStyle !== void 0) {\n          style = defaultStyle;\n        }\n        if (defaultLabelStyle !== void 0) {\n          labelStyle = defaultLabelStyle;\n        }\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"solid\";\n        break;\n      case \"dotted\":\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"dotted\";\n        edgeData.style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n        break;\n      case \"thick\":\n        edgeData.thickness = \"thick\";\n        edgeData.pattern = \"solid\";\n        edgeData.style = \"stroke-width: 3.5px;fill:none;\";\n        break;\n    }\n    if (edge.style !== void 0) {\n      const styles2 = getStylesFromArray(edge.style);\n      style = styles2.style;\n      labelStyle = styles2.labelStyle;\n    }\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n    }\n    edgeData.labelType = edge.labelType;\n    edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n    if (edge.style === void 0) {\n      edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none;\";\n    }\n    edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n    edgeData.id = linkId;\n    edgeData.classes = \"flowchart-link \" + linkNameStart + \" \" + linkNameEnd;\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n    const { source, target, sourceId, targetId } = getEdgeStartEndPoint(edge, dir);\n    log.debug(\"abc78 source and target\", source, target);\n    graph.edges.push({\n      id: \"e\" + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      sourceId,\n      targetId,\n      labelEl,\n      labels: [\n        {\n          width: edgeData.width,\n          height: edgeData.height,\n          orgWidth: edgeData.width,\n          orgHeight: edgeData.height,\n          text: edgeData.label,\n          layoutOptions: {\n            \"edgeLabels.inline\": \"true\",\n            \"edgeLabels.placement\": \"CENTER\"\n          }\n        }\n      ],\n      edgeData\n    });\n  });\n  return graph;\n};\nconst addMarkersToEdge = function(svgPath, edgeData, diagramType, arrowMarkerAbsolute, id) {\n  let url = \"\";\n  if (arrowMarkerAbsolute) {\n    url = window.location.protocol + \"//\" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, \"\\\\(\");\n    url = url.replace(/\\)/g, \"\\\\)\");\n  }\n  addEdgeMarkers(svgPath, edgeData, url, id, diagramType);\n};\nconst getClasses = function(text, diagObj) {\n  log.info(\"Extracting classes\");\n  return diagObj.db.getClasses();\n};\nconst addSubGraphs = function(db2) {\n  const parentLookupDb = { parentById: {}, childrenById: {} };\n  const subgraphs = db2.getSubGraphs();\n  log.info(\"Subgraphs - \", subgraphs);\n  subgraphs.forEach(function(subgraph) {\n    subgraph.nodes.forEach(function(node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n      if (parentLookupDb.childrenById[subgraph.id] === void 0) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n  subgraphs.forEach(function(subgraph) {\n    ({ id: subgraph.id });\n    if (parentLookupDb.parentById[subgraph.id] !== void 0) {\n      parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\nconst calcOffset = function(src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n  if (ancestor === void 0 || ancestor === \"root\") {\n    return { x: 0, y: 0 };\n  }\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return { x: ancestorOffset.posX, y: ancestorOffset.posY };\n};\nconst insertEdge = function(edgesEl, edge, edgeData, diagObj, parentLookupDb, id) {\n  const offset = calcOffset(edge.sourceId, edge.targetId, parentLookupDb);\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n  const segPoints = segments.map((segment) => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [\n    [src.x + offset.x, src.y + offset.y],\n    ...segPoints,\n    [dest.x + offset.x, dest.y + offset.y]\n  ];\n  const { x, y } = getLineFunctionsWithOffset(edge.edgeData);\n  const curve = line().x(x).y(y).curve(curveLinear);\n  const edgePath = edgesEl.insert(\"path\").attr(\"d\", curve(points)).attr(\"class\", \"path \" + edgeData.classes).attr(\"fill\", \"none\");\n  const edgeG = edgesEl.insert(\"g\").attr(\"class\", \"edgeLabel\");\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr(\"width\", box.width);\n  edgeWithLabel.attr(\"height\", box.height);\n  edgeG.attr(\n    \"transform\",\n    `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`\n  );\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute, id);\n};\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach((node) => {\n    if (!node.children) {\n      node.children = [];\n    }\n    const childIds = parentLookupDb.childrenById[node.id];\n    if (childIds) {\n      childIds.forEach((childId) => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n    insertChildren(node.children, parentLookupDb);\n  });\n};\nconst draw = async function(text, id, _version, diagObj) {\n  var _a;\n  diagObj.db.clear();\n  nodeDb = {};\n  portPos = {};\n  diagObj.db.setGen(\"gen-2\");\n  diagObj.parser.parse(text);\n  const renderEl = select(\"body\").append(\"div\").attr(\"style\", \"height:400px\").attr(\"id\", \"cy\");\n  let graph = {\n    id: \"root\",\n    layoutOptions: {\n      \"elk.hierarchyHandling\": \"INCLUDE_CHILDREN\",\n      \"org.eclipse.elk.padding\": \"[top=100, left=100, bottom=110, right=110]\",\n      \"elk.layered.spacing.edgeNodeBetweenLayers\": \"30\",\n      // 'elk.layered.mergeEdges': 'true',\n      \"elk.direction\": \"DOWN\"\n      // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n    },\n    children: [],\n    edges: []\n  };\n  log.info(\"Drawing flowchart using v3 renderer\", elk);\n  let dir = diagObj.db.getDirection();\n  switch (dir) {\n    case \"BT\":\n      graph.layoutOptions[\"elk.direction\"] = \"UP\";\n      break;\n    case \"TB\":\n      graph.layoutOptions[\"elk.direction\"] = \"DOWN\";\n      break;\n    case \"LR\":\n      graph.layoutOptions[\"elk.direction\"] = \"RIGHT\";\n      break;\n    case \"RL\":\n      graph.layoutOptions[\"elk.direction\"] = \"LEFT\";\n      break;\n  }\n  const { securityLevel, flowchart: conf2 } = getConfig();\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n  const svg = root.select(`[id=\"${id}\"]`);\n  const markers = [\"point\", \"circle\", \"cross\"];\n  insertMarkers(svg, markers, diagObj.type, id);\n  const vert = diagObj.db.getVertices();\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info(\"Subgraphs - \", subGraphs);\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(\n      subG.id,\n      { text: subG.title, type: subG.labelType },\n      \"group\",\n      void 0,\n      subG.classes,\n      subG.dir\n    );\n  }\n  const subGraphsEl = svg.insert(\"g\").attr(\"class\", \"subgraphs\");\n  const parentLookupDb = addSubGraphs(diagObj.db);\n  graph = await addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n  const edgesEl = svg.insert(\"g\").attr(\"class\", \"edges edgePath\");\n  const edges = diagObj.db.getEdges();\n  graph = addEdges(edges, diagObj, graph, svg);\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach((nodeId) => {\n    const node = nodeDb[nodeId];\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n    if (parentLookupDb.childrenById[nodeId] !== void 0) {\n      node.labels = [\n        {\n          text: node.labelText,\n          layoutOptions: {\n            \"nodeLabels.placement\": \"[H_CENTER, V_TOP, INSIDE]\"\n          },\n          width: node.labelData.width,\n          height: node.labelData.height\n          // width: 100,\n          // height: 100,\n        }\n      ];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info(\"after layout\", JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info(\"after layout\", g);\n  (_a = g.edges) == null ? void 0 : _a.map((edge) => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb, id);\n  });\n  setupGraphViewbox({}, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  renderEl.remove();\n};\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function(node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height\n      };\n      if (node.type === \"group\") {\n        const subgraphEl = subgraphsEl.insert(\"g\").attr(\"class\", \"subgraph\");\n        subgraphEl.insert(\"rect\").attr(\"class\", \"subgraph subgraph-lvl-\" + depth % 5 + \" node\").attr(\"x\", node.x + relX).attr(\"y\", node.y + relY).attr(\"width\", node.width).attr(\"height\", node.height);\n        const label = subgraphEl.insert(\"g\").attr(\"class\", \"label\");\n        const labelCentering = getConfig().flowchart.htmlLabels ? node.labelData.width / 2 : 0;\n        label.attr(\n          \"transform\",\n          `translate(${node.labels[0].x + relX + node.x + labelCentering}, ${node.labels[0].y + relY + node.y + 3})`\n        );\n        label.node().appendChild(node.labelData.labelNode);\n        log.info(\"Id (UGH)= \", node.type, node.labels);\n      } else {\n        log.info(\"Id (UGH)= \", node.id);\n        node.el.attr(\n          \"transform\",\n          `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`\n        );\n      }\n    }\n  });\n  nodeArray.forEach(function(node) {\n    if (node && node.type === \"group\") {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\nconst renderer = {\n  getClasses,\n  draw\n};\nconst genSections = (options) => {\n  let sections = \"\";\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n  return sections;\n};\nconst getStyles = (options) => `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.85;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n\n  .flowchart-label text {\n    text-anchor: middle;\n  }\n\n  ${genSections(options)}\n`;\nconst styles = getStyles;\nconst diagram = {\n  db,\n  renderer,\n  parser,\n  styles\n};\nexport {\n  diagram\n};\n"],"names":[],"mappings":";AAgrBA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA"}